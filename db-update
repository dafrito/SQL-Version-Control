#!/bin/bash
# Updates a database by running patches
PATH=/bin:/usr/bin:$HOME/bin:${0%/*}

source db-load-settings.sh;
source db-get-password.sh;

installed=/tmp/db-update-$db-installed.$$
staged=/tmp/db-update-$db-staged.$$
tables_before=/tmp/db-update-$db-tables-before.$$
tables_after=/tmp/db-update-$db-tables-after.$$
last_error=/tmp/db-update-$db-error.$$
function cleanup {
    rm -f $installed $staged $tables_before $tables_after $last_error
}
trap cleanup EXIT
trap 'echo; cleanup; exit 1' INT TERM
touch $installed
touch $staged

if mysql $db -u "$user" -p"$PASSWORD" -e'show tables' -N | egrep -x "patches" >/dev/null; then
    if ! mysql $db -u "$user" -p"$PASSWORD" -e"select patch from patches order by order_applied" -N >$installed; then
        exit 2
    fi;
else
    NEW=0
fi

function patch_allowed {
    if [[ ! $1 =~ ^@ ]]; then
        return 0;
    fi
    while [[ $1 =~ ^@ ]]; do
        if [[ "@$BUILD" == $1 ]]; then
            return 0
        fi
        shift
    done
    return 1
}

function get_staged {
    IFS='
'
    for patch in $(cat $1)
    do
        patch=${patch%%#*}
        if [ -z "$patch" ]; then
            continue
        fi
        IFS='   '
        set -- $patch >/dev/null
        if ! patch_allowed $*; then
            continue
        fi
        while [[ $1 =~ ^@ ]]; do
            shift
        done
        if [[ $1 =~ \\.list ]]; then
            if [ -e $root/$1 ]; then
                get_staged $root/$1
            elif [ -e $1 ]; then
                get_staged $1
            else
                echo "db: $1 does not exist in '$root' or current dir" 1>&2
                exit 1
            fi
        elif [ ! -e $root/$1 ]; then
            echo "db: $1 does not exist in $root" 1>&2
            exit 1
        elif ! egrep $1 <$installed >/dev/null; then
            echo $*
        fi
    done 
}

get_staged $patchlist >$staged
if [ ! -s "$staged" ]; then
    echo "db: $db up-to-date" 1>&2
    exit 0;
fi
if [ ! $FORCE ]; then
    echo "Available updates for $db:"
    cat -n $staged | awk '{ print $1 ". " $2 }'
    read -p"Install updates to $db? (y/n): " r
    case $r in
        y*) ;;
        *) exit 1
    esac
fi

if [ $NEW ]; then
    if [ -s ${0%/*}/init.sql ]; then
        mysql $db -u "$user" -p"$PASSWORD" <${0%/*}/init.sql
    fi
    if [ -s $CONFIG_ROOT/init.sql ]; then
        mysql $db -u "$user" -p"$PASSWORD" <$CONFIG_ROOT/init.sql
    fi
    if [ -s $BUILD_CONFIG_ROOT/init.sql ]; then
        mysql $db -u "$user" -p"$PASSWORD" <$BUILD_CONFIG_ROOT/init.sql
    fi
fi

function log_table {
    mysql $db -u "$user" -p"$PASSWORD" -e"insert into patch_changelog (patch, table_name, type) values ('$2', '$3', '$1')" 2>$last_error
    if [ -s $last_error ]; then
        error=`cat $last_error`
        echo $error | egrep "^ERROR 1062 " >/dev/null && echo $error | egrep "$2"-"$3" >/dev/null && return
        echo $error 1>&2
        exit 2
    fi
}

IFS='
'
i=1
for patch in `cat $staged`
do
    IFS='   '
    set $patch
    patch_name=$1
    echo "$i. $patch_name"
    let i++
    shift
    if ! mysql $db -u "$user" -p"$PASSWORD" -e"show tables" -N | source db-filter-tables.sh | sort >$tables_before; then
        exit 2
    fi;
    pushd $root >/dev/null
    case $patch_name in
        *.sql)
            if ! mysql $db -u "$user" -p"$PASSWORD" <$patch_name >>$log; then
                exit 2
            fi ;;
        *)
            if ! source $patch_name >>$log; then
                exit 2
            fi ;;
    esac
    if ! mysql $db -u "$user" -p"$PASSWORD" -e"insert into patches (patch, who_applied) values ('$patch_name', '$(whoami)');"; then
        exit 2
    fi;
    popd >/dev/null
    if ! mysql $db -u "$user" -p"$PASSWORD" -e"show tables" -N | source db-filter-tables.sh | sort >$tables_after; then
        exit 2
    fi;
    IFS='
'
    for line in `diff -U 0 $tables_before $tables_after`; do
        case $line in
            ---*|+++*|@@*) continue ;;
            +*) log_table 'create' $patch_name ${line:1} ;;
            -*) log_table 'drop' $patch_name ${line:1} ;;
        esac
    done;
    IFS='   '
    for table; do
        if [ $table = "Tables_in_$db" ]; then
            continue;
        fi
        case $table in
            +*) 
                table=${table:1};
                if egrep -x "$table" <$tables_before >/dev/null; then
                    echo "db: '$table' existed before '$patch_name' was executed" 1>&2
                    exit 1
                fi
                if ! egrep -x "$table" <$tables_after >/dev/null; then
                    echo "db: '$table' does not exist, even though '$patch_name' claimed to have created it" 1>&2
                    exit 1
                fi
                log_table 'create' $patch_name ${line:1} ;log_table 'create' $patch_name ${line:1}
                ;;
            -*) 
                table=${table:1};
                if ! egrep -x "$table" <$tables_before >/dev/null; then
                    echo "db: '$table' does not exist, and could not have been removed by '$patch_name'" 1>&2
                    exit 1
                fi
                if egrep -x "$table" <$tables_after >/dev/null; then
                    echo "db '$table' still exists, even though '$patch_name' claimed to have removed it" 1>&2
                    exit 1
                fi
                log_table 'drop' $patch_name ${line:1} 
                ;;
            *) 
                if egrep -x "$table" <$tables_before >/dev/null; then
                    if egrep -x "$table" <$tables_after >/dev/null; then
                        log_table 'alter' $patch_name $table
                    else
                        log_table 'drop' $patch_name $table
                    fi
                elif egrep -x "$table" <$tables_after >/dev/null; then
                    log_table 'create' $patch_name $table
                else
                    echo "$0: '$table' was not created or removed, but was listed for '$patch_name'" 1>&2
                    exit 1
                fi
        esac
    done
done;

if [ $dump ]; then
    source db-dump >$BUILD-dump.sql
fi
